<!DOCTYPE html>
<html>
<head>
    <title></title>
    <script src="pixi.js"></script>
    <script src="quadtree.js"></script>
    <script src="spriteUtilities.js"></script>
    <meta charset="utf-8" />
</head>
<body>
    <script>
        var app = new PIXI.Application(window.innerWidth, window.innerHeight, { backgroundColor: 0x1099bb }, { antialias: true });
        var myTree = new Quadtree({
            x: 0,
            y: 0,
            width: window.innerWidth,
            height: window.innerHeight
        },1);
        document.body.appendChild(app.view);
        var Frstcontainer = new PIXI.Container();
       // app.renderer
        Frstcontainer.width = app.view.width / 3;
        Frstcontainer.height = app.view.height / 2;

        var Scndcontainer = new PIXI.Container();
        var Thrdcontainer = new PIXI.Container();
        var Frthcontainer = new PIXI.Container();
        var Fifthcontainer = new PIXI.Container();

        Scndcontainer.position.x = 400;
        //Scndcontainer.width=
        Thrdcontainer.position.x = 800;
        Frthcontainer.position.y = 400
        Fifthcontainer.position.x = 40;
        Fifthcontainer.position.y = 400;

        //Create the temperature bar
        var tempBar = new PIXI.Container();
        tempBar.position.set(26, 180)
        Frstcontainer.addChild(tempBar); var bar, temp = 200;
        var tempText

        app.stage.addChild(Frstcontainer);
        app.stage.addChild(Scndcontainer);
        app.stage.addChild(Thrdcontainer);
        app.stage.addChild(Frthcontainer);
        app.stage.addChild(Fifthcontainer);
        let u = new SpriteUtilities(PIXI); // sprite utilities

        var circle = new PIXI.Graphics();
        circle.interactive = true;
        
        var shapes = []; // to draw traingular grid atoms
        var atomarray = [];  // to draw atom that are to be dragged
        shapes = atomPlacement(4, 6);


        function atomPlacement(rownumber, columnnumber) {
            var shapes = [];
            var rown = rownumber;
            var col = columnnumber; // for width 1000 and ht 1000 for canvas gap value seems right;
            // gap, height, width
            var gap;
            var cellH;
            var cellW;
            var no = rown / 2;
            gap = 53.333333333333336; // hard coded to fit in less no of values
            var sqrt = 1; // added to accomadate to change space between columns

            if (col > 15) {   // added to create width dynamically to accomodate more columns  depending on canvas width
                gap = s.width / col;
                sqrt = 3;
            }
            var no1 = col - 1; // not used
            for (var i = 1; i <= col; i++) {
                for (var j = 1; j <= col; j++) {
                    // stroke(255);

                    //gap = s.width / col;
                    cellW = gap;
                    cellH = Math.sqrt(sqrt) * gap;
                    /*      point(i*cellW, j*cellH);
                     point(i*cellW - cellW/2, j*cellH - cellH/2); */
                    // vertex(i * cellW, j * cellH);
                    if (i < col) {               // add one  cordinate less to bottom line
                        var xcor = i * cellW; // bottom one one
                        var ycor = j * cellH;
                    }



                    var xcor2 = i * cellW - cellW / 2; // top one
                    var ycor2 = j * cellH - cellH / 2;


                    // even no of rows
                    if (rown % 2 == 0) {
                        if (j <= no) {
                            // array to add cordinates and radius
                            shapes.push({
                                x: xcor2, // x cor
                                y: ycor2, // y cor
                                radius: 10, // radius hardcoded for time being
                                fill: '#AAAAAA' // color
                                // Add element.
                            });
                            if (i < col) { // added so that bottom row will have one less than top
                                shapes.push({

                                    x: xcor,
                                    y: ycor,
                                    radius: 10,
                                    fill: '#AAAAAA'
                                    // Add element.
                                });
                            }
                        }
                        //even no of row
                    }
                        //odd number of rows push more top row
                    else {
                        if (j <= no + 1) {
                            shapes.push({

                                x: xcor2,
                                y: ycor2,
                                radius: 10,
                                fill: '#AAAAAA'
                                // Add element.
                            });
                        }//top one}
                        //push less bottom row as odd no
                        if (j < no) {
                            shapes.push({

                                x: xcor,
                                y: ycor,
                                radius: 10,
                                fill: '#AAAAAA'
                                // Add element.
                            });
                        }
                    }

                }
            }
            return shapes;
        }


        draw1(shapes);
        //var circle = new PIXI.Graphics();
        //circle.interactive = true;
        function draw1(shapes) {
            var shapes1 = shapes;
            var l = shapes1.length;

            // draw each shape
            for (var i = 0; i < l; i++) {
                myTree.insert(shapes1[i]);
                circle.beginFill(0xFFFF0B);
                circle.drawCircle(shapes1[i].x, shapes1[i].y, 10);
                //circle.position.x = shapes1[i].x;
                //circle.position.y = shapes1[i].y;
                circle.endFill();
               // Frstcontainer.addChild(circle);
               // Scndcontainer.addChild(circle);
               // Thrdcontainer.addChild(circle);
             //   Frthcontainer.addChild(circle);
            }
            Frstcontainer.addChild(circle);
            var circle2 = new PIXI.Graphics();
            circle2.interactive = true;
            for (var i = 0; i < l; i++) {

            //    myTree.insert(shapes1[i]);
                circle2.beginFill(0xFFFF0B);
                circle2.drawCircle(shapes1[i].x, shapes1[i].y, 10);
                circle2.endFill();

            }
            Scndcontainer.addChild(circle2);
            atom = new PIXI.Graphics();
            //  atom.buttonMode = true;
            // this button mode will mean the hand cursor appears when you roll over the bunny with your mouse
            atom.buttonMode = true;

            // center the bunny's anchor point
            atom.anchor = 0.5;

            // make it a bit bigger, so it's easier to grab
            //  atom.scale.set(3);

                atom.interactive = true;
                atom.beginFill(0x333333);
                atom.drawCircle(0, 0, 10);
                atom.position.x = 20;
                atom.position.y = 20;
                atom.endFill();
               // myObjects = [];
               var atomobj ={

                   x: 20,
                   y: 20,
                   radius: 10,
                    fill: '#AAAAAA'
                    // Add element.
               };

             //  myTree.insert(atomobj);
                //atom.scale.x = atom.scale.y = 0.5;
                atom
            // events for drag start
            .on('mousedown', onDragStart)
            .on('touchstart', onDragStart)
            // events for drag end
            .on('mouseup', onDragEnd)
            .on('mouseupoutside', onDragEnd)
            .on('touchend', onDragEnd)
            .on('touchendoutside', onDragEnd)
            // events for drag move
            .on('mousemove', onDragMove)
            .on('touchmove', onDragMove);

                atom2 = new PIXI.Graphics();
                atom2.interactive = true;
                atom2.beginFill(0x990000);
                atom2.drawCircle(0, 0, 10);
                atom2.position.x = 20;
                atom2.position.y = 70;
                atom2.endFill();
          
            // this button mode will mean the hand cursor appears when you roll over the bunny with your mouse
                atom2.buttonMode = true;

            // center the bunny's anchor point
                atom2.anchor = 0.5;
                atom2
                        // events for drag start
                        .on('mousedown', onDragStart)
                        .on('touchstart', onDragStart)
                        // events for drag end
                        .on('mouseup', onDragEnd)
                        .on('mouseupoutside', onDragEnd)
                        .on('touchend', onDragEnd)
                        .on('touchendoutside', onDragEnd)
                        // events for drag move
                        .on('mousemove', onDragMove)
                        .on('touchmove', onDragMove);
                Frthcontainer.addChild(atom);
                Frthcontainer.addChild(atom2);
                Frthcontainer.interactive = true;

                atom3 = new PIXI.Graphics();
                atom4 = new PIXI.Graphics();
                atom5 = new PIXI.Graphics();
                //atom3.interactive = true;
              //  var atomarray = [];
                atomarray = atomPlacement(2, 2)

                //for (var i = 0; i < atomarray.length; i++) {
            
                    atom3.beginFill(0x990000);
                    atom3.drawCircle(0, 0, 10);
                    atom3.position.x = atomarray[0].x;
                    atom3.position.y = atomarray[0].y
                  //  atom3.graphicsData[i].shape.
                    atom3.endFill();
                    atom4.beginFill(0x990000);
                    atom4.drawCircle(0, 0, 10);
                    atom4.position.x = atomarray[1].x;
                    atom4.position.y = atomarray[1].y
            //  atom3.graphicsData[i].shape.
                    atom4.endFill();
                    atom5.beginFill(0x990000);
                    atom5.drawCircle(0, 0, 10);
                    atom5.position.x = atomarray[2].x;
                    atom5.position.y = atomarray[2].y
            //  atom3.graphicsData[i].shape.
                    atom5.endFill();
                //    }
                    Fifthcontainer.addChild(atom3);
                    Fifthcontainer.addChild(atom4);
                    Fifthcontainer.addChild(atom5);
                Fifthcontainer.interactive=true;
            Fifthcontainer
               // events for drag start
               .on('mousedown', onDragStart2)
               .on('mouseup', onDragEnd)
               .on('mouseupoutside', onDragEnd)
               // events for drag move
               .on('mousemove', onDragMove)


            //Create the black background rectangle
            var innerBar = new PIXI.Graphics();
            innerBar.lineStyle(2, 0xffd900, 1);
            innerBar.beginFill(0x000000,0.25);
            innerBar.drawRoundedRect(10, 0, 220, 40,15);
            innerBar.endFill();
            
            tempBar.addChild(innerBar);
            //Create the front red rectangle
            //var outerBar = new PIXI.Graphics();
            //outerBar.beginFill(0xFF3300);
            //outerBar.drawRect(0, 0, 128, 8);
            //outerBar.endFill();
            //tempBar.addChild(outerBar);
            //tempBar.outer = outerBar;

            bar =  new PIXI.Sprite.fromImage('img/healthBar.png');
            tempBar.addChild(bar);
            bar.position.x = 20;
            bar.position.y = 10;
            bar.width = 200;
            bar.height = 20;
            //bar.anchor.x = 0.5
           bar.scale.x = 0.5;
           bar.scale.y = 0.5;
            //  tempBar.mask = innerBar;
            tempText = new PIXI.Text('T: '+ temp+'F', {
               fontWeight: 'bold', fontSize: 20, fontFamily: 'Arial', fill: '0xffd900', dropShadow: true
           , dropShadowColor: '#000000', dropShadowBlur: 4, dropShadowAnlge: Math.PI / 6, dropShadowDistance: 6
           });
           tempText.x = innerBar.width / 2-40;
           tempText.y = innerBar.height + 2;
           tempBar.addChild(tempText);
            //bar.sc
      //      bar.rotation=


        }

        function onDragStart(event) {
            // store a reference to the data
            // the reason for this is because of multitouch
            // we want to track the movement of this particular touch
            this.data = event.data;
            this.alpha = 0.5;
            this.dragging = true;
            this.sx = this.data.getLocalPosition(event.currentTarget).x;
            this.sy = this.data.getLocalPosition(event.currentTarget).y;
        }
        var first, second, third;
        function onDragStart2(event) {
            // store a reference to the data
            // the reason for this is because of multitouch
            // we want to track the movement of this particular touch
            this.data = event.data;
            this.alpha = 0.5;
            this.dragging = true;
            this.sx = this.data.getLocalPosition(event.currentTarget).x;
            this.sy = this.data.getLocalPosition(event.currentTarget).y;
            for (var i = 0; i < atomarray.length; i++) {

                //    var areaX = this.sx - atomarray[i].x;
                //  var areaY = this.sy - atomarray[i].y;
                var areaX = this.sx - event.currentTarget.children[i].x
                var areaY = this.sy - event.currentTarget.children[i].y;
                //return true if x^2 + y^2 <= radius squared. if the click is inside change color
                if (areaX * areaX + areaY * areaY <= 10 * 10) {
                    if (i == 0) {
                        first = true;
                    }
                    if (i == 1) {
                        second = true;
                    }
                    if (i == 2) {
                        third = true;

                    }
                    break;
                }
            }
        }


        function onDragEnd(event) {
            this.alpha = 1;
            this.dragging = false;
            // set the interaction data to null
            this.data = event.data;
            var shapes1 = shapes;
            var l = shapes1.length;
            var container = true; // boolean variable to determine the container

            var postion = app.renderer.plugins.interaction.mouse.global;
            var containername;
            if (postion.x > 400 && postion.x < 800) { var newPosition = app.renderer.plugins.interaction.mouse.getLocalPosition(Scndcontainer); container = false; }
            if (postion.x > 0 && postion.x < 400) {
                var newPosition = app.renderer.plugins.interaction.mouse.getLocalPosition(Frstcontainer);
            }

            if (container) {
                containername = Frstcontainer;
            }
            else {
                containername = Scndcontainer;
            }
            var myCursor = {
                x: newPosition.x,
                y: newPosition.y,
                radius: 10,
                fill: '#AAAAAA'
            };
            var position1 = {};
            var candidates = [];
            var candidates1;

            // for multiple atom drag and placement
            if (event.currentTarget.children.length > 1) {
                candidates = myTree.retrieve(myCursor);
                for (var i = 0; i < candidates.length; i++) {
                    var areaX = myCursor.x - candidates[i].x;
                    var areaY = myCursor.y - candidates[i].y;
                    //return true if x^2 + y^2 <= radius squared. if the click is inside change color
                    if (areaX * areaX + areaY * areaY <= 20 * 20) {
                        candidates1 = candidates[i];
                    }
                }




                if (first) {
                    event.currentTarget.x = candidates1.x - 26.66666668;
                    event.currentTarget.y = candidates1.y - 26.66666668;

                    first = false;
                }
                if (second) {
                    event.currentTarget.x = candidates1.x - 26.66666668 - 26.66666668;
                    event.currentTarget.y = candidates1.y - 26.66666668 - 26.66666668;

                    second = false;
                }
                if (third) {
                    event.currentTarget.x = candidates1.x - 26.66666668 - 26.66666668 - 26.66666668;
                    event.currentTarget.y = candidates1.y - 26.66666668;
                    third = false;
                }

            }

                // for single atom drag
            else {

                var x = event.currentTarget.toLocal(event.currentTarget.position, containername).x;
                var y = event.currentTarget.toLocal(event.currentTarget.position, containername).y;
                x = event.currentTarget.position.x - x;
                y = y - event.currentTarget.position.y;
                y = -y;

                var myCursor1 = {
                    x: x,
                    y: y,
                    radius: 10,
                    fill: '#AAAAAA'
                };
                candidates = myTree.retrieve(myCursor1);
                for (var i = 0; i < candidates.length; i++) {
                    var areaX = x - candidates[i].x;
                    var areaY = y - candidates[i].y;
                    //return true if x^2 + y^2 <= radius squared. if the click is inside change color
                    if (areaX * areaX + areaY * areaY <= 20 * 20) {
                        event.currentTarget.x = candidates[i].x;
                        event.currentTarget.y = candidates[i].y;
                    }
                }

            }
        //    tempBar.outer.width -= 1;
            //  this.life = 100;
            if (temp>0) {
                temp = temp - 20;
                bar.width = temp;
changetemp=temp;
jitter +=0.001 ;
                tempText.text = 'T: ' + temp + 'F';
            }
           
            event.currentTarget.setParent(containername);

        }

        function onDragMove() {
            if (this.dragging) {
                var newPosition = this.data.getLocalPosition(this.parent);
                //   var newPosition = app.renderer.plugins.interaction.mouse.getLocalPosition(this.parent);
                // var newPosition=app.renderer.plugins.interaction.mouse.getLocalPosition(Frthcontainer);
                // var newPosition = this.data.global;
                this.x = newPosition.x - this.sx;
                this.y = newPosition.y - this.sy;


            }
        }
        gameLoop();
      var jitter =0.001;
     
        function gameLoop() {
            requestAnimationFrame(gameLoop);

            if (temp<200) {
              
          u.shake(circle, jitter, true);  
            }
            //Update the SpriteUtilities library each frame
            
            app.renderer.render(app.stage);
            u.update();
        }

        
       //  M W F     4 pm
        // T THR     11.30 am

    </script>
</body>
</html>

