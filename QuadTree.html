<!DOCTYPE html>
<html>
<head>
    <title></title>
    <script src="pixi.js"></script>
    <script src="quadtree.js"></script>"
    <meta charset="utf-8" />
</head>
<body>
    <script>
        var app = new PIXI.Application(window.innerWidth, window.innerHeight, { backgroundColor: 0x1099bb }, { antialias: true });
        var myTree = new Quadtree({
            x: 0,
            y: 0,
            width: window.innerWidth,
            height: window.innerHeight
        },1);
        document.body.appendChild(app.view);
        var Frstcontainer = new PIXI.Container();

        Frstcontainer.width = app.view.width / 3;
        Frstcontainer.height = app.view.height / 2;

        var Scndcontainer = new PIXI.Container();
        var Thrdcontainer = new PIXI.Container();
        var Frthcontainer = new PIXI.Container();
        var Fifthcontainer = new PIXI.Container();

        Scndcontainer.position.x = 400;
        //Scndcontainer.width=
        Thrdcontainer.position.x = 800;
        Frthcontainer.position.y = 400
        Fifthcontainer.position.x = 40;
        Fifthcontainer.position.y = 400;

        app.stage.addChild(Frstcontainer);
        app.stage.addChild(Scndcontainer);
        app.stage.addChild(Thrdcontainer);
        app.stage.addChild(Frthcontainer);
        app.stage.addChild(Fifthcontainer);

        var circle = new PIXI.Graphics();
        circle.interactive = true;
        var shapes = [];
       shapes= atomPlacement(4, 6);
        function atomPlacement(rownumber, columnnumber) {
            var shapes = [];
            var rown = rownumber;
            var col = columnnumber; // for width 1000 and ht 1000 for canvas gap value seems right;
            // gap, height, width
            var gap;
            var cellH;
            var cellW;
            var no = rown / 2;
            gap = 53.333333333333336; // hard coded to fit in less no of values
            var sqrt = 1; // added to accomadate to change space between columns

            if (col > 15) {   // added to create width dynamically to accomodate more columns  depending on canvas width
                gap = s.width / col;
                sqrt = 3;
            }
            var no1 = col - 1; // not used
            for (var i = 1; i <= col; i++) {
                for (var j = 1; j <= col; j++) {
                    // stroke(255);

                    //gap = s.width / col;
                    cellW = gap;
                    cellH = Math.sqrt(sqrt) * gap;
                    /*      point(i*cellW, j*cellH);
                     point(i*cellW - cellW/2, j*cellH - cellH/2); */
                    // vertex(i * cellW, j * cellH);
                    if (i < col) {               // add one  cordinate less to bottom line
                        var xcor = i * cellW; // bottom one one
                        var ycor = j * cellH;
                    }



                    var xcor2 = i * cellW - cellW / 2; // top one
                    var ycor2 = j * cellH - cellH / 2;


                    // even no of rows
                    if (rown % 2 == 0) {
                        if (j <= no) {
                            // array to add cordinates and radius
                            shapes.push({
                                x: xcor2, // x cor
                                y: ycor2, // y cor
                                radius: 10, // radius hardcoded for time being
                                fill: '#AAAAAA' // color
                                // Add element.
                            });
                            if (i < col) { // added so that bottom row will have one less than top
                                shapes.push({

                                    x: xcor,
                                    y: ycor,
                                    radius: 10,
                                    fill: '#AAAAAA'
                                    // Add element.
                                });
                            }
                        }
                        //even no of row
                    }
                        //odd number of rows push more top row
                    else {
                        if (j <= no + 1) {
                            shapes.push({

                                x: xcor2,
                                y: ycor2,
                                radius: 10,
                                fill: '#AAAAAA'
                                // Add element.
                            });
                        }//top one}
                        //push less bottom row as odd no
                        if (j < no) {
                            shapes.push({

                                x: xcor,
                                y: ycor,
                                radius: 10,
                                fill: '#AAAAAA'
                                // Add element.
                            });
                        }
                    }

                }
            }
            return shapes;
        }
        draw1(shapes);
        //var circle = new PIXI.Graphics();
        //circle.interactive = true;
        function draw1(shapes) {
            var shapes1 = shapes;
            var l = shapes1.length;

            // draw each shape
            for (var i = 0; i < l; i++) {
                myTree.insert(shapes1[i]);
                circle.beginFill(0xFFFF0B);
                circle.drawCircle(shapes1[i].x, shapes1[i].y, 10);
                //circle.position.x = shapes1[i].x;
                //circle.position.y = shapes1[i].y;
                circle.endFill();
               // Frstcontainer.addChild(circle);
               // Scndcontainer.addChild(circle);
               // Thrdcontainer.addChild(circle);
             //   Frthcontainer.addChild(circle);
            }
            Frstcontainer.addChild(circle);
            var circle2 = new PIXI.Graphics();
            circle2.interactive = true;
            for (var i = 0; i < l; i++) {

            //    myTree.insert(shapes1[i]);
                circle2.beginFill(0xFFFF0B);
                circle2.drawCircle(shapes1[i].x, shapes1[i].y, 10);
                //circle.position.x = shapes1[i].x;
                //circle.position.y = shapes1[i].y;
                circle2.endFill();

                // Frstcontainer.addChild(circle);
                // Scndcontainer.addChild(circle);
                // Thrdcontainer.addChild(circle);
                //   Frthcontainer.addChild(circle);

            }
            Scndcontainer.addChild(circle2);
            atom = new PIXI.Graphics();
            //  atom.buttonMode = true;
            // this button mode will mean the hand cursor appears when you roll over the bunny with your mouse
            atom.buttonMode = true;

            // center the bunny's anchor point
            atom.anchor = 0.5;

            // make it a bit bigger, so it's easier to grab
            //  atom.scale.set(3);

                atom.interactive = true;
                atom.beginFill(0x333333);
                atom.drawCircle(0, 0, 10);
                atom.position.x = 20;
                atom.position.y = 20;
                atom.endFill();
               // myObjects = [];
               var atomobj ={

                   x: 20,
                   y: 20,
                   radius: 10,
                    fill: '#AAAAAA'
                    // Add element.
               };

             //  myTree.insert(atomobj);
                //atom.scale.x = atom.scale.y = 0.5;
                atom
            // events for drag start
            .on('mousedown', onDragStart)
            .on('touchstart', onDragStart)
            // events for drag end
            .on('mouseup', onDragEnd)
            .on('mouseupoutside', onDragEnd)
            .on('touchend', onDragEnd)
            .on('touchendoutside', onDragEnd)
            // events for drag move
            .on('mousemove', onDragMove)
            .on('touchmove', onDragMove);

            function onDragStart(event) {
                // store a reference to the data
                // the reason for this is because of multitouch
                // we want to track the movement of this particular touch
                this.data = event.data;
                this.alpha = 0.5;
                this.dragging = true;
                this.sx = this.data.getLocalPosition(event.currentTarget).x;
                this.sy = this.data.getLocalPosition(event.currentTarget).y;
            }
            var first, second, third;
            function onDragStart2(event) {
                // store a reference to the data
                // the reason for this is because of multitouch
                // we want to track the movement of this particular touch
                this.data = event.data;
                this.alpha = 0.5;
                this.dragging = true;
                this.sx = this.data.getLocalPosition(event.currentTarget).x;
                this.sy = this.data.getLocalPosition(event.currentTarget).y;
                for (var i = 0; i <atomarray.length; i++) {

                //    var areaX = this.sx - atomarray[i].x;
                    //  var areaY = this.sy - atomarray[i].y;
                    var areaX = this.sx - event.currentTarget.children[i].x
                    var areaY = this.sy - event.currentTarget.children[i].y;
                    //return true if x^2 + y^2 <= radius squared. if the click is inside change color
                    if (areaX * areaX + areaY * areaY <= 10 * 10)
                    {
                        if ( i==0) {
                            first = true;
                        }
                        if( i==1)
                        {
                            second = true;
                        }
                        if (i==2) {
                            third = true;

                        }
                        break;
                    }
                }
            }


            function onDragEnd(event) {
               this.alpha = 1;
                this.dragging = false;
                // set the interaction data to null
                this.data = event.data;
                //this.data.Glo
              //  var newPosition = this.data.getGlobalPosition();
                var shapes1 = shapes;
                var l = shapes1.length;
                //  console.log(Frstcontain);
                var container = true; // boolean variable to determine the container
                var postion = app.renderer.plugins.interaction.mouse.target;
                var containername;
                if (postion.data.global.x > 400 && postion.data.global.x < 800) { var newPosition = app.renderer.plugins.interaction.mouse.getLocalPosition(Scndcontainer);  container = false;}
                if (postion.data.global.x > 0 && postion.data.global.x < 400) {
                    var newPosition = app.renderer.plugins.interaction.mouse.getLocalPosition(Frstcontainer);
                }

                if (container) {
                    containername=  Frstcontainer;
                }
                else {
                    containername = Scndcontainer;
                }
                var myCursor = {
                    x: newPosition.x,
                    y: newPosition.y,
                    radius: 10,
                    fill: '#AAAAAA'
                };
                var position1 = {};
                var candidates = [];
                var candidates1 ;


                        if (event.currentTarget.children.length > 1) {
                         //   event.currentTarget.x = 26.66666668;
                          //  event.currentTarget.y = 26.66666668;
                            candidates = myTree.retrieve(myCursor);
                          //  var x = event.currentTarget.toLocal(event.currentTarget.position, containername).x;
                           // var y = event.currentTarget.toLocal(event.currentTarget.position, containername).y;
                            //x = event.currentTarget.position.x - x;
                            //y = y - event.currentTarget.position.y;
                            //y = -y;
                            for (var i = 0; i < candidates.length; i++) {
                                var areaX = myCursor.x - candidates[i].x;
                                var areaY = myCursor.y - candidates[i].y;
                                //return true if x^2 + y^2 <= radius squared. if the click is inside change color
                                if (areaX * areaX + areaY * areaY <= 20 * 20) {
                                    candidates1 = candidates[i];
                                }
                            }




                           if (first) {
                               event.currentTarget.x = candidates1.x - 26.66666668;
                               event.currentTarget.y = candidates1.y - 26.66666668;
                          //      event.currentTarget.graphicsData[1].shape.x = shapes1[i].x + 26.66666668;
                          //      event.currentTarget.graphicsData[1].shape.y = shapes1[i].y + 26.66666668
                          //      event.currentTarget.graphicsData[2].shape.x = shapes1[i].x+26.66666668+26.666668;
                          //      event.currentTarget.graphicsData[2].shape.y = shapes1[i].y;
                          //      event.currentTarget.setParent(Frstcontainer);
                                first = false;
                           }
                           if (second) {
                               event.currentTarget.x = candidates1.x - 26.66666668 - 26.66666668;
                               event.currentTarget.y = candidates1.y - 26.66666668 - 26.66666668;
                          //      event.currentTarget.graphicsData[0].shape.x = shapes1[i-1].x;
                          //      event.currentTarget.graphicsData[0].shape.y = shapes1[i-1].y;
                          //      event.currentTarget.graphicsData[2].shape.x = shapes1[i].x + 26.66666668;
                          //      event.currentTarget.graphicsData[2].shape.y =  shapes1[i-1].y;
                          //      event.currentTarget.graphicsData[1].shape.x = shapes1[i].x;
                          //      event.currentTarget.graphicsData[1].shape.y = shapes1[i].y;
                          //      event.currentTarget.setParent(Frstcontainer);
                                second = false;
                            }
                           if (third) {
                               event.currentTarget.x = candidates1.x - 26.66666668 - 26.66666668 - 26.66666668;
                               event.currentTarget.y = candidates1.y - 26.66666668;
                          //      event.currentTarget.graphicsData[0].shape.x = shapes1[i].x - 26.66666668 - 26.666668;
                          //      event.currentTarget.graphicsData[0].shape.y = shapes1[i].y;
                          //      event.currentTarget.graphicsData[1].shape.x = shapes1[i].x - 26.66666668;
                          //      event.currentTarget.graphicsData[1].shape.y = shapes1[i].y + 26.66666668;
                          //      event.currentTarget.graphicsData[2].shape.x = shapes1[i].x;
                          //      event.currentTarget.graphicsData[2].shape.y = shapes1[i].y;
                          //      event.currentTarget.setParent(Frstcontainer);
                                third = false;
                            }
                      
                        }
                        
                        else {
                           
                            var x = event.currentTarget.toLocal(event.currentTarget.position, containername).x;
                            var y = event.currentTarget.toLocal(event.currentTarget.position, containername).y;
                            x = event.currentTarget.position.x-x;
                            y = y - event.currentTarget.position.y;
                            y = -y;

                            var myCursor1 = {
                                x: x,
                                y: y,
                                radius: 10,
                                fill: '#AAAAAA'
                            };
                            candidates = myTree.retrieve(myCursor1);
                            for (var i = 0; i < candidates.length; i++) {
                                var areaX = x - candidates[i].x;
                                var areaY = y - candidates[i].y;
                                //return true if x^2 + y^2 <= radius squared. if the click is inside change color
                                if (areaX * areaX + areaY * areaY <= 20 * 20) {
                                    event.currentTarget.x = candidates[i].x;
                                    event.currentTarget.y = candidates[i].y;}
                            }
                           // var x = this.x;
                            //var y = this.y;
                            //var position = event.data.global.getLocalPosition(Frstcontainer);
                           // var point = new PIXI.Point;
                            //point.x = shapes[1].x;
                            //point.y = shapes[1].y;
                            //var transform = atom.localTransform.applyInverse(Frstcontainer);
                           // var transform = atom.localTransform.apply(point);
                          //  var position = this.event.data.getLocalPosition(atom).x;
                            
                           // this.x = position.x;this.y =position.y
                          //  var position1 = this.data.getLocalPosition(event.currentTarget.graphicsData[0].shape).y;
                        }
                        event.currentTarget.setParent(containername);

                        // if (color == 3355443) {

                       //  }
                       //  else {
                         //    if (container) {
                           //      atom2.setParent(Frstcontainer);
                            // }
                             //else {
                              //   atom2.setParent(Scndcontainer);
                             //}
                       //}
                          // atom.setParent(Frstcontainer);
                            // atom.y = shapes1[i].y
                           // atom.graphicsData[0].shape.x = shapes1[i].x;
                            //atom.graphicsData[0].shape.y = shapes1[i].y;
                      //  }
                        //else {
                            //circle2.beginFill("" + a + "x" + b);
                          ////  circle2.beginFill(color);
                            //circle.beginFill(
                            ////circle2.drawCircle(shapes1[i].x, shapes[i].y, 10);
                            ////circle2.endFill();
                         //   circle2.graphicsData[i].destroy();
                        ////}
                        //if (event.target.graphicsData[0].shape.y == 70) {
                        //    atom2.clear();
                        //}
                        //else {
                        //    atom.clear();
                        //}

                    }

                
             //   if (!collisiondetected)
               // {
               //     event.target.x = event.currentTarget.graphicsData[0].x;
               //     event.target.y = event.currentTarget.graphicsData[0].y;
               // }
                //if (!colorChanged) {
                //    if (event.target.graphicsData[0].shape.y == 70) {
                //        atom2.destroy();
                //    }
                //    else {
                //        atom.clear();
                //    }
                //}
                //stage.addChild(circle);
                //renderer.render(stage);
                //if (container) {
                //    Frstcontainer.addChild(circle);
                //}
                //else {
                //    Scndcontainer.addChild(circle2)
                //}


            
            function onDragMove() {
                if (this.dragging) {
                  var newPosition = this.data.getLocalPosition(this.parent);
                    //   var newPosition = app.renderer.plugins.interaction.mouse.getLocalPosition(this.parent);
                    // var newPosition=app.renderer.plugins.interaction.mouse.getLocalPosition(Frthcontainer);
                   // var newPosition = this.data.global;
                    this.x = newPosition.x -this.sx;
                    this.y = newPosition.y - this.sy;


               }
            }


                atom2 = new PIXI.Graphics();
                atom2.interactive = true;
                atom2.beginFill(0x990000);
                atom2.drawCircle(0, 0, 10);
                atom2.position.x = 20;
                atom2.position.y = 70;
                atom2.endFill();
            //  atom.buttonMode = true;
            // this button mode will mean the hand cursor appears when you roll over the bunny with your mouse
                atom2.buttonMode = true;

            // center the bunny's anchor point
                atom2.anchor = 0.5;
                atom2
                        // events for drag start
                        .on('mousedown', onDragStart)
                        .on('touchstart', onDragStart)
                        // events for drag end
                        .on('mouseup', onDragEnd)
                        .on('mouseupoutside', onDragEnd)
                        .on('touchend', onDragEnd)
                        .on('touchendoutside', onDragEnd)
                        // events for drag move
                        .on('mousemove', onDragMove)
                        .on('touchmove', onDragMove);
                Frthcontainer.addChild(atom);
                Frthcontainer.addChild(atom2);
                Frthcontainer.interactive = true;

                atom3 = new PIXI.Graphics();
                atom4 = new PIXI.Graphics();
                atom5 = new PIXI.Graphics();
                //atom3.interactive = true;
                var atomarray = [];
                atomarray = atomPlacement(2, 2)

                //for (var i = 0; i < atomarray.length; i++) {

                    atom3.beginFill(0x990000);
                    atom3.drawCircle(0, 0, 10);
                    atom3.position.x = atomarray[0].x;
                    atom3.position.y = atomarray[0].y
                  //  atom3.graphicsData[i].shape.
                    atom3.endFill();
                    atom4.beginFill(0x990000);
                    atom4.drawCircle(0, 0, 10);
                    atom4.position.x = atomarray[1].x;
                    atom4.position.y = atomarray[1].y
            //  atom3.graphicsData[i].shape.
                    atom4.endFill();
                    atom5.beginFill(0x990000);
                    atom5.drawCircle(0, 0, 10);
                    atom5.position.x = atomarray[2].x;
                    atom5.position.y = atomarray[2].y
            //  atom3.graphicsData[i].shape.
                    atom5.endFill();
                //    }
                    Fifthcontainer.addChild(atom3);
                    Fifthcontainer.addChild(atom4);
                    Fifthcontainer.addChild(atom5);
                Fifthcontainer.interactive=true;
            Fifthcontainer
               // events for drag start
               .on('mousedown', onDragStart2)
               .on('mouseup', onDragEnd)
               .on('mouseupoutside', onDragEnd)
               // events for drag move
               .on('mousemove', onDragMove)

        }
       //  M W F     4 pm
        // T THR     11.30 am

    </script>
</body>
</html>
